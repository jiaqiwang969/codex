import fs from 'node:fs/promises';
import path from 'node:path';
import { execa } from 'execa';
import chalk from 'chalk';
import { listSessionFiles } from './sessionFinder.js';
import { extractSessionMetaQuick } from './metaQuick.js';

const WORKSPACE_SESSIONS_FILE = '.cxresume_sessions';
const SESSION_ID_RE = /session id:\s*([0-9a-fA-F-]+)/i;

function dedupePreserveOrder(items) {
  const seen = new Set();
  const out = [];
  for (const item of items) {
    if (item && !seen.has(item)) {
      seen.add(item);
      out.push(item);
    }
  }
  return out;
}

export function getWorkspaceSessionsPath(dir) {
  return path.join(dir, WORKSPACE_SESSIONS_FILE);
}

export async function readWorkspaceSessionIds(dir) {
  const filePath = getWorkspaceSessionsPath(dir);
  let content;
  try {
    content = await fs.readFile(filePath, 'utf8');
  } catch (err) {
    if (err?.code === 'ENOENT') return [];
    throw err;
  }
  const ids = [];
  for (const line of content.split(/\r?\n/)) {
    const match = SESSION_ID_RE.exec(line);
    if (match?.[1]) ids.push(match[1].trim());
  }
  return dedupePreserveOrder(ids);
}

async function appendSessionLine(dir, line) {
  const filePath = getWorkspaceSessionsPath(dir);
  const entry = line.endsWith('\n') ? line : `${line.trim()}\n`;
  await fs.appendFile(filePath, entry, 'utf8');
}

async function createWorkspaceSession({ codexCmd, cwd }) {
  const base = String(codexCmd || 'codex').trim() || 'codex';
  const args = ['e', 'Session generated by cxresume', '-m', 'unsupported model'];
  const child = execa(base, args, { cwd, all: true, reject: false });
  let buffer = '';
  let capturedLine = null;
  let capturedId = null;
  const handleLine = (lineRaw) => {
    if (!lineRaw) return;
    const line = lineRaw.trim();
    if (!line) return;
    const match = SESSION_ID_RE.exec(line);
    if (match?.[1] && !capturedId) {
      capturedId = match[1].trim();
      capturedLine = line;
      try { child.kill('SIGINT', { forceKillAfterTimeout: 200 }); } catch {}
    }
  };
  child.all?.setEncoding('utf8');
  child.all?.on('data', chunk => {
    buffer += chunk;
    let idx;
    while ((idx = buffer.indexOf('\n')) !== -1) {
      const piece = buffer.slice(0, idx);
      buffer = buffer.slice(idx + 1);
      handleLine(piece);
      if (capturedId) break;
    }
    if (capturedId) buffer = '';
    // prevent buffer from growing without limit
    if (buffer.length > 4096) buffer = buffer.slice(-2048);
  });
  const result = await child;
  if (!capturedId && buffer) {
    handleLine(buffer);
    buffer = '';
  }
  if (!capturedId) {
    const errMsg = result.failed
      ? (result.stderr || result.stdout || result.shortMessage || result.message || 'unknown error')
      : '未能从 Codex 输出中解析到 session id';
    throw new Error(String(errMsg).trim());
  }
  return { id: capturedId, line: capturedLine || `session id: ${capturedId}` };
}

export async function createWorkspaceSessionAndRecord(dir, { codexCmd } = {}) {
  const created = await createWorkspaceSession({ codexCmd, cwd: dir });
  await appendSessionLine(dir, created.line);
  return created;
}

export async function ensureWorkspaceSessionIds(dir, { codexCmd } = {}) {
  const existing = await readWorkspaceSessionIds(dir);
  if (existing.length) return existing;
  try {
    const created = await createWorkspaceSessionAndRecord(dir, { codexCmd });
    return [created.id];
  } catch (err) {
    const hint = chalk?.red ? chalk.red : (x => x);
    console.error(hint(`创建新的 Codex session 失败：${err?.shortMessage || err?.message || err}`));
    throw err;
  }
}

export async function findSessionsByIds(root, ids) {
  const targetIds = dedupePreserveOrder(ids || []);
  if (!targetIds.length) return { files: [], missingIds: [] };
  const idSet = new Set(targetIds);
  const files = await listSessionFiles(root);
  const found = new Map();
  for (const file of files) {
    if (!idSet.size) break;
    try {
      const meta = await extractSessionMetaQuick(file.path);
      const sessionId = meta?.id;
      if (sessionId && idSet.has(sessionId) && !found.has(sessionId)) {
        found.set(sessionId, { ...file, sessionId });
        idSet.delete(sessionId);
        continue;
      }
      if (!sessionId) {
        for (const candidate of Array.from(idSet)) {
          if (file.path.includes(candidate) || file.rel?.includes(candidate)) {
            found.set(candidate, { ...file, sessionId: candidate });
            idSet.delete(candidate);
            break;
          }
        }
      }
    } catch {
      // ignore parse failures
    }
  }
  const ordered = [];
  for (const id of targetIds) {
    if (found.has(id)) ordered.push(found.get(id));
  }
  return { files: ordered, missingIds: targetIds.filter(id => !found.has(id)) };
}
