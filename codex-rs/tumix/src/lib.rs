//! TUMIX - Multi-Agent Parallel Execution Framework
//!
//! TUMIX enables running 15 specialized agents in parallel, each working in isolated
//! Git worktrees with cloned conversation contexts via `resume-clone`.

pub mod executor;
pub mod meta;
pub mod worktree;

use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::fmt;
use std::fs;
use std::path::PathBuf;
use std::sync::{Arc, Mutex};
use tokio::task::JoinSet;

/// Agent configuration generated by meta-agent
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentConfig {
    pub id: String,
    pub name: String,
    pub role: String,
}

/// Result from a single agent execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AgentResult {
    pub agent_id: String,
    pub session_id: String,
    pub commit_hash: String,
    pub branch: String,
    pub jsonl_path: String,
}

/// Round 1 execution report
#[derive(Debug)]
pub struct Round1Result {
    pub agents: Vec<AgentResult>,
}

/// Progress callback for reporting status updates
pub type ProgressCallback = Box<dyn Fn(String) + Send + Sync>;

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub(crate) enum SessionStatus {
    Running,
    Completed,
    Failed,
}

impl fmt::Display for SessionStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SessionStatus::Running => write!(f, "running"),
            SessionStatus::Completed => write!(f, "completed"),
            SessionStatus::Failed => write!(f, "failed"),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) struct SessionRecord {
    pub agent_id: String,
    pub agent_name: String,
    pub status: SessionStatus,
    pub branch: String,
    pub session_id: Option<String>,
    pub commit: Option<String>,
    pub jsonl_path: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
}

#[derive(Debug)]
pub(crate) struct SessionRecorder {
    path: PathBuf,
    records: Mutex<Vec<SessionRecord>>,
}

impl SessionRecorder {
    pub(crate) fn new(path: PathBuf) -> Result<Self> {
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent)?;
        }

        let recorder = Self {
            path,
            records: Mutex::new(Vec::new()),
        };
        recorder.write_snapshot(&[])?;
        Ok(recorder)
    }

    fn write_snapshot(&self, snapshot: &[SessionRecord]) -> Result<()> {
        let json = serde_json::to_vec_pretty(snapshot)?;
        fs::write(&self.path, json)?;
        Ok(())
    }

    fn update_records<F>(&self, updater: F) -> Result<()>
    where
        F: FnOnce(&mut Vec<SessionRecord>),
    {
        let mut records = self.records.lock().unwrap();
        updater(&mut records);
        let snapshot = records.clone();
        drop(records);
        self.write_snapshot(&snapshot)
    }

    pub(crate) fn init_agent(&self, agent_id: &str, agent_name: &str, branch: &str) -> Result<()> {
        let agent_id = agent_id.to_string();
        let agent_name = agent_name.to_string();
        let branch = branch.to_string();

        self.update_records(|records| {
            let record = SessionRecord {
                agent_id: agent_id.clone(),
                agent_name: agent_name.clone(),
                status: SessionStatus::Running,
                branch: branch.clone(),
                session_id: None,
                commit: None,
                jsonl_path: None,
                error: None,
            };

            if let Some(existing) = records.iter_mut().find(|r| r.agent_id == agent_id) {
                *existing = record;
            } else {
                records.push(record);
            }
        })
    }

    pub(crate) fn record_session_start(
        &self,
        agent_id: &str,
        session_id: &str,
        jsonl_path: &str,
    ) -> Result<()> {
        let session_id = session_id.to_string();
        let jsonl_path = jsonl_path.to_string();

        self.update_records(|records| {
            if let Some(record) = records.iter_mut().find(|r| r.agent_id == agent_id) {
                record.session_id = Some(session_id.clone());
                record.jsonl_path = Some(jsonl_path.clone());
            } else {
                records.push(SessionRecord {
                    agent_id: agent_id.to_string(),
                    agent_name: String::new(),
                    status: SessionStatus::Running,
                    branch: String::new(),
                    session_id: Some(session_id.clone()),
                    commit: None,
                    jsonl_path: Some(jsonl_path.clone()),
                    error: None,
                });
            }
        })
    }

    pub(crate) fn record_completion(&self, result: &AgentResult, agent_name: &str) -> Result<()> {
        let agent_name = agent_name.to_string();

        self.update_records(|records| {
            let mut completed = SessionRecord {
                agent_id: result.agent_id.clone(),
                agent_name: agent_name.clone(),
                status: SessionStatus::Completed,
                branch: result.branch.clone(),
                session_id: Some(result.session_id.clone()),
                commit: Some(result.commit_hash.clone()),
                jsonl_path: Some(result.jsonl_path.clone()),
                error: None,
            };

            if let Some(existing) = records.iter_mut().find(|r| r.agent_id == result.agent_id) {
                if !existing.agent_name.is_empty() {
                    completed.agent_name = existing.agent_name.clone();
                }
                if existing.branch.is_empty() {
                    completed.branch = result.branch.clone();
                }
                *existing = completed;
            } else {
                records.push(completed);
            }
        })
    }

    pub(crate) fn record_failure(&self, agent_id: &str, error: &str) -> Result<()> {
        let error_owned = error.to_string();

        self.update_records(|records| {
            if let Some(record) = records.iter_mut().find(|r| r.agent_id == agent_id) {
                record.status = SessionStatus::Failed;
                record.error = Some(error_owned.clone());
            } else {
                records.push(SessionRecord {
                    agent_id: agent_id.to_string(),
                    agent_name: String::new(),
                    status: SessionStatus::Failed,
                    branch: String::new(),
                    session_id: None,
                    commit: None,
                    jsonl_path: None,
                    error: Some(error_owned.clone()),
                });
            }
        })
    }

    #[cfg(test)]
    fn snapshot(&self) -> Vec<SessionRecord> {
        self.records.lock().unwrap().clone()
    }
}

/// Main entry point for TUMIX execution
pub async fn run_tumix(
    parent_session: String,
    user_prompt: Option<String>,
    progress_cb: Option<ProgressCallback>,
) -> Result<Round1Result> {
    let progress_arc = progress_cb.map(Arc::new);

    let report = |msg: String| {
        tracing::info!("{}", msg);
        if let Some(ref cb) = progress_arc {
            cb(msg.clone());
        }
    };

    let run_id = chrono::Local::now().format("%Y%m%d-%H%M%S").to_string();
    report(format!(
        "ğŸš€ TUMIXå¯åŠ¨ - Run ID: {} - åŸºäºsession: {}",
        &run_id,
        &parent_session[..8]
    ));

    report("ğŸ§  Meta-agentåˆ†æä»»åŠ¡ï¼Œè®¾è®¡ä¸“å®¶å›¢é˜Ÿ...".to_string());
    let agents = match meta::generate_agents(&parent_session, user_prompt).await {
        Ok(agents) => {
            report(format!("âœ… Meta-agentæˆåŠŸç”Ÿæˆ {} ä¸ªä¸“å®¶è§’è‰²", agents.len()));
            agents
        }
        Err(e) => {
            report(format!("âŒ Meta-agentæ‰§è¡Œå¤±è´¥: {}", e));
            return Err(e);
        }
    };

    if agents.is_empty() {
        anyhow::bail!("Meta-agentè¿”å›äº†ç©ºåˆ—è¡¨ï¼Œæ— æ³•ç»§ç»­æ‰§è¡Œ");
    }

    let names = agents.iter().map(|a| &a.name).collect::<Vec<_>>();
    report(format!("âœ… ç”Ÿæˆä¸“å®¶åˆ—è¡¨: {:?}", names));

    let repo_path = std::env::current_dir()?;
    let worktree_mgr = worktree::WorktreeManager::new(&repo_path, &run_id)?;

    report(format!("ğŸ“ åˆ›å»º {} ä¸ªç‹¬ç«‹å·¥ä½œç©ºé—´...", agents.len()));
    let mut worktrees = Vec::with_capacity(agents.len());
    for agent in &agents {
        let wt = worktree_mgr.create(&agent.id)?;
        report(format!("  âœ“ åˆ›å»ºworktree: {} ({})", wt.branch, agent.name));
        worktrees.push(wt);
    }
    report("âœ… æ‰€æœ‰worktreesåˆ›å»ºå®Œæˆ".to_string());

    report(format!("ğŸš€ {} ä¸ªä¸“å®¶å¼€å§‹å¹¶è¡Œå·¥ä½œ...", agents.len()));

    let sessions_path = PathBuf::from(format!(".tumix/round1_sessions_{}.json", run_id));
    let session_recorder = Arc::new(SessionRecorder::new(sessions_path.clone())?);

    let exec = executor::AgentExecutor::new(parent_session);
    let mut join_set = JoinSet::new();

    for (agent, worktree) in agents.into_iter().zip(worktrees.into_iter()) {
        let exec_clone = exec.clone();
        let agent_id = agent.id.clone();
        let agent_name = agent.name.clone();
        let branch_name = worktree.branch.clone();
        let progress_clone = progress_arc.clone();
        let run_id_clone = run_id.clone();
        let session_recorder_task = session_recorder.clone();

        join_set.spawn(async move {
            let report_task = |msg: String| {
                tracing::info!("{}", msg);
                if let Some(ref cb) = progress_clone {
                    cb(msg);
                }
            };

            if let Err(e) =
                session_recorder_task
                    .clone()
                    .init_agent(&agent_id, &agent_name, &branch_name)
            {
                report_task(format!(
                    "  âš ï¸ Failed to initialize session record for agent {}: {}",
                    agent_id, e
                ));
            }

            let recorder_for_exec = session_recorder_task.clone();
            let recorder_for_finalize = session_recorder_task.clone();

            let result = exec_clone
                .execute(&agent, &worktree, recorder_for_exec, &run_id_clone)
                .await;

            match &result {
                Ok(r) => {
                    report_task(format!(
                        "  âœ… Agent {} ({}) å®Œæˆ: commit {} @ {}",
                        agent_id,
                        agent_name,
                        &r.commit_hash[..8],
                        r.branch
                    ));
                    if let Err(e) = recorder_for_finalize.record_completion(r, &agent_name) {
                        report_task(format!(
                            "  âš ï¸ Failed to persist session result for agent {}: {}",
                            agent_id, e
                        ));
                    }
                }
                Err(e) => {
                    let error_msg = format!("{}", e);
                    report_task(format!(
                        "  âŒ Agent {} ({}) å¤±è´¥: {}",
                        agent_id, agent_name, e
                    ));
                    if let Err(rec_err) =
                        recorder_for_finalize.record_failure(&agent_id, &error_msg)
                    {
                        report_task(format!(
                            "  âš ï¸ Failed to mark agent {} as failed: {}",
                            agent_id, rec_err
                        ));
                    }
                }
            }

            result
        });
    }

    let mut results = Vec::new();
    let mut errors = Vec::new();

    while let Some(res) = join_set.join_next().await {
        match res {
            Ok(Ok(result)) => results.push(result),
            Ok(Err(e)) => errors.push(format!("{}", e)),
            Err(e) => errors.push(format!("Task panic: {}", e)),
        }
    }

    report(format!(
        "âœ¨ Round 1 å®Œæˆï¼{} ä¸ªä¸“å®¶æˆåŠŸæ‰§è¡Œï¼Œ{} ä¸ªå¤±è´¥",
        results.len(),
        errors.len()
    ));

    if !errors.is_empty() {
        report("âš ï¸ å¤±è´¥çš„agents:".to_string());
        for (i, err) in errors.iter().enumerate() {
            report(format!("  {}: {}", i + 1, err));
        }
    }

    report(format!("ğŸ’¾ Sessionåˆ—è¡¨å·²ä¿å­˜: {}", sessions_path.display()));

    if results.is_empty() && !errors.is_empty() {
        anyhow::bail!(
            "æ‰€æœ‰agentsæ‰§è¡Œå¤±è´¥ã€‚é”™è¯¯:
{}",
            errors.join(
                "
"
            )
        );
    }

    Ok(Round1Result { agents: results })
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn session_recorder_tracks_success_flow() {
        let dir = tempdir().unwrap();
        let path = dir.path().join("sessions.json");
        let recorder = SessionRecorder::new(path.clone()).unwrap();

        recorder.init_agent("01", "Architect", "branch-01").unwrap();
        recorder
            .record_session_start("01", "session-1", "/tmp/sess.jsonl")
            .unwrap();

        let result = AgentResult {
            agent_id: "01".to_string(),
            session_id: "session-1".to_string(),
            commit_hash: "deadbeef".to_string(),
            branch: "branch-01".to_string(),
            jsonl_path: "/tmp/sess.jsonl".to_string(),
        };

        recorder.record_completion(&result, "Architect").unwrap();

        let snapshot = recorder.snapshot();
        assert_eq!(snapshot.len(), 1);
        let record = &snapshot[0];
        assert_eq!(record.status, SessionStatus::Completed);
        assert_eq!(record.session_id.as_deref(), Some("session-1"));
        assert_eq!(record.commit.as_deref(), Some("deadbeef"));
        assert_eq!(record.jsonl_path.as_deref(), Some("/tmp/sess.jsonl"));
        assert!(record.error.is_none());
    }

    #[test]
    fn session_recorder_handles_failure_without_init() {
        let dir = tempdir().unwrap();
        let path = dir.path().join("sessions.json");
        let recorder = SessionRecorder::new(path).unwrap();

        recorder.record_failure("99", "boom").unwrap();

        let snapshot = recorder.snapshot();
        assert_eq!(snapshot.len(), 1);
        let record = &snapshot[0];
        assert_eq!(record.agent_id, "99");
        assert_eq!(record.status, SessionStatus::Failed);
        assert_eq!(record.error.as_deref(), Some("boom"));
    }
}
